[{"title":"创建DeepSeek本地部署Python版本","url":"/hexo/2025/08/07/CreateDeepSeek/","content":"\n　最近想创建一个AI翻译机器人，加截图翻译，虽然效果不太好，但是机器人确实搞好了，记录下\n\n安装依赖（主要难点）\n首先确认Python的版本不要太新，我这里是 3.11\n打开PyTorch官网 https://pytorch.org/get-started/locally/\n下载PyTorch官网显示的Cuba版本 https://developer.nvidia.com/cuda-toolkit-archive\n安装PyTorch官网显示的命令\n\nllama_cpp 库 安装$env:CMAKE_ARGS=&quot;-DGGML_CUDA=on&quot;pip install llama-cpp-python[server] --upgrade --force-reinstall --no-cache-dir\n如果你出问题了，请检查CUDA,Python版本,PyTorch版本是否匹配\n下载DeepSeek模型一般从 https://huggingface.co/deepseek-ai/deepseek-coder-7b-instruct-GGUF 获取国内可以用：https://www.modelscope.cn/models/unsloth/DeepSeek-R1-Distill-Qwen-7B-GGUF/resolve/master/DeepSeek-R1-Distill-Qwen-7B-Q4_K_M.ggufhttps://www.modelscope.cn/models/unsloth/DeepSeek-R1-Distill-Qwen-14B-GGUF/resolve/master/DeepSeek-R1-Distill-Qwen-14B-Q4_K_M.gguf\n代码import timefrom llama_cpp import Llama# ===== 硬件优化配置 =====MODEL_PATH = r&quot;models\\DeepSeek-R1-Distill-Qwen-7B-Q4_K_M.gguf&quot;GPU_LAYERS = 30  # RTX 3050 Ti 推荐30层CPU_THREADS = 20   # 3900X分配6线程MAX_TOKENS = 4096 # 最大生成长度# ===== R1专用参数 =====SYSTEM_PROMPT = &quot;你是一个专业的翻译官，你的任务是将下面提供给你的文本翻译成可供中国人阅读的中文，只输出翻译结果，不要其他额外的输出&quot;# ===== 模型初始化 =====print(&quot;⏳ 正在加载DeepSeek-R1模型，请稍候...&quot;)start_time = time.time()llm = Llama(    model_path=MODEL_PATH,    n_gpu_layers=30,    n_threads=20,    n_ctx=4096,    n_batch=512,    verbose=True)load_time = time.time() - start_timeprint(f&quot;✅ 模型加载完成! 耗时: &#123;load_time:.1f&#125;秒&quot;)# ===== R1专用对话格式 =====def format_r1_prompt(user_input):    return [        &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: SYSTEM_PROMPT&#125;,        &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: user_input&#125;    ]# ===== 流式输出函数 =====def generate_response(prompt):    try:        response = llm.create_chat_completion(            messages=format_r1_prompt(prompt),            max_tokens=MAX_TOKENS,            temperature=0.7,            stop=[&quot;&lt;|im_end|&gt;&quot;],            stream=True        )                full_response = &quot;&quot;        for chunk in response:            delta = chunk[&#x27;choices&#x27;][0][&#x27;delta&#x27;]            if &#x27;content&#x27; in delta:                content = delta[&#x27;content&#x27;]                print(content, end=&#x27;&#x27;, flush=True)                full_response += content        return full_response    except Exception as e:        return f&quot;❌ 生成错误: &#123;str(e)&#125;&quot;# ===== 主交互循环 =====print(&quot;\\n🤖 DeepSeek-R1助手已就绪（输入&#x27;exit&#x27;退出）&quot;)print(&quot;💡 提示：R1是通用对话模型，适合各类问题\\n&quot;)while True:    try:        # 获取用户输入        user_input = input(&quot;\\n👤 您: &quot;)                if user_input.lower() == &#x27;exit&#x27;:            print(&quot;🛑 助手已退出&quot;)            break                # 生成回复        print(&quot;🤖 R1: &quot;, end=&#x27;&#x27;, flush=True)        start_gen = time.time()                # 流式输出        response = generate_response(user_input)                # 性能统计        gen_time = time.time() - start_gen        tokens = len(llm.tokenize(response.encode()))        print(f&quot;\\n⏱️ 生成耗时: &#123;gen_time:.1f&#125;s | 📝 令牌数: &#123;tokens&#125;&quot;)            except KeyboardInterrupt:        print(&quot;\\n🛑 操作已中断&quot;)        break","categories":["开发编程"],"tags":["AI"]},{"title":"MQTT的初次研究","url":"/hexo/2025/09/16/MQTT%E7%9A%84%E5%88%9D%E6%AC%A1%E7%A0%94%E7%A9%B6/","content":"MQTT是一种基于发布&#x2F;订阅模式的轻量级消息传输协议，可以实现类似智能家居的通信，需要一个中间者\nMQTT服务器搭建  (不能商用)\ndocker pull emqx/emqx\n启动容器\ndocker run -d --name emqx -p 1883:1883 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx:latest\n发布者\nimport timeimport paho.mqtt.client as mqttimport jsonMQTT_SERVER = &#x27;localhost&#x27;MQTT_PORT = 1883client = mqtt.Client()client.connect(MQTT_SERVER, MQTT_PORT, 60)client.loop_start()data = &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;tiger&quot;, &quot;status&quot;: 0, &quot;timestamp&quot;: time.time()&#125;while True:    if(data[&#x27;status&#x27;] == 0):        data[&#x27;status&#x27;] = 1    else:        data[&#x27;status&#x27;] = 0    msg = json.dumps(data)    client.publish(&#x27;test&#x27;, msg, 1)    print(&#x27;send:&#x27;, data)    time.sleep(1)\n\n订阅者\nimport paho.mqtt.client as mqttimport jsonMQTT_SERVER = &#x27;localhost&#x27;MQTT_PORT = 1883# 定义消息处理函数def on_message(client, userdata, msg):    try:        # 尝试解析JSON数据        data = json.loads(msg.payload)        print(f&quot;收到主题 &#123;msg.topic&#125; 的消息: &#123;data&#125;&quot;)    except json.JSONDecodeError:        # 如果不是JSON格式，直接打印原始消息        print(f&quot;收到主题 &#123;msg.topic&#125; 的消息: &#123;msg.payload&#125;&quot;)# 创建客户端实例client = mqtt.Client()# 先设置消息处理函数client.on_message = on_message# 连接到MQTT服务器client.connect(MQTT_SERVER, MQTT_PORT, 60)# 订阅主题client.subscribe(&#x27;test&#x27;, 1)# 开始循环处理client.loop_start()# 保持程序运行try:    while True:        pass  # 保持主程序运行except KeyboardInterrupt:    print(&quot;程序已停止&quot;)    client.loop_stop()    client.disconnect()"},{"title":"RootShellForTermux","url":"/hexo/2025/08/23/RootShellForTermux/","content":"在使用adb Shell时无法调用Termux工具，记录下解决方法\n# 配置 Termux 命令路径export PATH=/data/data/com.termux/files/usr/bin:/data/data/com.termux/files/usr/bin/applets:$PATH# 配置 Termux 库路径export LD_LIBRARY_PATH=/data/data/com.termux/files/usr/lib#调用工具实例python /data/data/com.termux/files/home/script/main.py"},{"title":"跳过Windows OOBE联网","url":"/hexo/2025/07/28/SkipWindowsActivation/","content":"在OOBE中按下Shift + F10进入命令行，执行以下命令：\nstart ms-cxh:localonly\n然后输入用户名，密码可选\n\n密码如果不输入，那么会跳过欢迎界面\n\n","categories":["实用小技巧"],"tags":["操作系统"]},{"url":"/hexo/2025/10/11/TermuxDocker/","content":"Installing Docker in TermuxThis repository contains instructions on how to install Docker in Termux, a powerful terminal emulator for Android.\nPrerequisitesBefore proceeding with the installation, make sure you have the following prerequisites:\n\nAn Android device with Termux installed. You can download Termux from the F-Droid app store.\nStable internet connection.\n\nInstallation StepsFollow the steps below to install Docker in Termux:\n\nOpen Termux on your Android device.\n\nUpdate and upgrade the packages by running the following command:\n\n\npkg update -y &amp;&amp; pkg upgrade -y\n\n\nInstall the necessary dependencies by running the following command:\n\npkg install qemu-utils qemu-common qemu-system-x86_64-headless wget -y\n\n\nCreate a seperate directory:\n\nmkdir alpine &amp;&amp; cd alpine\n\n\nDownload Alpine Linux 3.20.2 (virt optimized) ISO:\n\nwget http://dl-cdn.alpinelinux.org/alpine/v3.20/releases/x86_64/alpine-virt-3.20.2-x86_64.iso\n\n\nCreate disk (note it won’t actually take 5GB of space, more like 500-600MB):\n\nqemu-img create -f qcow2 alpine.img 5G\n\n\nBoot it up:Here we’re using 1024MB of memory and 2 cpus\n\nqemu-system-x86_64 -machine q35 -m 1024 -smp cpus=2 -cpu qemu64 -drive if=pflash,format=raw,read-only=on,file=$PREFIX/share/qemu/edk2-x86_64-code.fd -netdev user,id=n1,dns=8.8.8.8,hostfwd=tcp::2222-:22 -device virtio-net,netdev=n1 -cdrom alpine-virt-3.20.2-x86_64.iso -nographic alpine.img\n\nyou can get number of useable cpus using nproc and total memory using free -m | grep -oP &#39;\\d+&#39; | head -n 1\n\nLogin with username root (no password)\n\n\n\nSetup network (press Enter to use defaults):\n\nlocalhost:~# setup-interfaces Available interfaces are: eth0. Enter &#x27;?&#x27; for help on bridges, bonding and vlans. Which one do you want to initialize? (or &#x27;?&#x27; or &#x27;done&#x27;) [eth0] Ip address for eth0? (or &#x27;dhcp&#x27;, &#x27;none&#x27;, &#x27;?&#x27;) [dhcp] Do you want to do any manual network configuration? [no]\nlocalhost:~# \nifup eth0\n\n\nCreate an answerfile to speed up installation:\n\nwget https://raw.githubusercontent.com/cyberkernelofficial/docker-in-termux/main/answerfile\n\nNOTE: If you see any error like this: wget: bad address &#39;gist.githubusercontent.com&#39;. Then run this command\necho -e &quot;nameserver 192.168.1.1\\nnameserver 1.1.1.1&quot; &gt; /etc/resolv.conf\n\nPatch setup-disk to enable serial console output on boot:\n\nsed -i -E &#x27;s/(local kernel_opts)=.*/\\1=&quot;console=ttyS0&quot;/&#x27; /sbin/setup-disk\n\n\nRun setup to install to disk\n\nsetup-alpine -f answerfile\n\n\nOnce installation is complete, power off the VM (command poweroff)\n\nBoot again without cdrom:\n\n\nqemu-system-x86_64 -machine q35 -m 1024 -smp cpus=2 -cpu qemu64 -drive if=pflash,format=raw,read-only=on,file=$PREFIX/share/qemu/edk2-x86_64-code.fd -netdev user,id=n1,dns=8.8.8.8,hostfwd=tcp::2222-:22 -device virtio-net,netdev=n1 -nographic alpine.img\n\nA -nano run_qemu.shIn the text editor, write the following:\n#!/bin/bashqemu-system-x86_64 -machine q35 -m 1024 -smp cpus=2 -cpu qemu64 -drive if=pflash,format=raw,read-only=on,file=$PREFIX/share/qemu/edk2-x86_64-code.fd -netdev user,id=n1,dns=8.8.8.8,hostfwd=tcp::2222-:22 -device virtio-net,netdev=n1 -nographic alpine.img\nSave and close the file. In nano, you can do this by pressing Ctrl+X, then Y to confirm saving, and then Enter to confirm the filename.\nB - chmod command: chmod +x run_qemu.sh\nC - ./run_qemu.sh\n\nUpdate system and install docker:\n\necho &quot;nameserver 8.8.8.8&quot; &gt; /etc/resolv.confecho &quot;nameserver 8.8.4.4&quot; &gt;&gt; /etc/resolv.confapk update &amp;&amp; apk add docker\n\n\nStart docker:\n\nservice docker start\n\n\nEnable docker on boot:\n\nrc-update add docker\n\n\nCheck docker install successfully or not:\n\ndocker run hello-world\n\nSome useful keys\nCtrl+a x: quit emulation\nCtrl+a h: toggle QEMU console\n\nUsageNow that Docker is installed in Termux, you can start using it to manage and run containers on your Android device. Refer to the official Docker documentation for more information on how to use Docker.\nContributingIf you encounter any issues during the installation process or have suggestions for improvements, please feel free to open an issue or submit a pull request.\nAcknowledgment\nThis article inspired from: https://gist.github.com/oofnikj/e79aef095cd08756f7f26ed244355d62\n\nLicenseThis project is licensed under the MIT License.\n"},{"title":"UbuntuOpenVpnClient","url":"/hexo/2025/08/20/UbuntuOpenVpnClient/","content":"sudo nmcli connection import type openvpn file &lt;openvpn配置文件路径&gt;sudo nmcli connection modify &lt;vpn_name&gt; vpn.user-name &quot;ShawLiu&quot;sudo nmcli connection up &lt;vpn_name&gt;\n\n\ndocker 创建Open VPN服务器\ndocker run -d   --name=openvpn-as --device /dev/net/tun   --cap-add=MKNOD --cap-add=NET_ADMIN   -p 943:943 -p 443:443 -p 1194:1194/udp   -v ./opt/openvpn:/openvpn   --restart=unless-stopped   openvpn/openvpn-as"},{"title":"创建博客（hexo）","url":"/hexo/2025/07/29/createBlog/","content":"需要的物品\n一台服务器(阿里云、腾讯云、华为云等)\nLiunx系统（Ubuntu）\n\n可选项\n域名\n备案\nSSL\n\n具体步骤：1. 安装 fnmwget https://github.com/Schniz/fnm/releases/download/v1.38.1/fnm-linux.zip\n2. 解压unzip fnm-linux.zip\n3. 移动到 ~&#x2F;.local&#x2F;binmv fnm ~/.local/bin\n4. 将fnm加入环境变量echo &#x27;export PATH=&quot;$HOME/.local/bin/fnm:$PATH&quot;&#x27; &gt;&gt; /etc/profileecho &#x27;eval &quot;$(fnm env)&quot;&#x27; &gt;&gt; /etc/profilesource /etc/profile\n5. 安装 nodejsfnm install 20.18.0fnm use 20.18.0\n6. 安装 hexonpm install hexo -g\n7. 初始化 hexomkdir blogcd bloghexo init\n\n测试搭建是否完成,使用命令 hexo server访问 http:&#x2F;&#x2F;【服务器IP】:4000 即可看到 hexo 博客\n\n8. 安装Butterfly主题点击进入 Butterfly官方教程在你的 Hexo 根目录内\ngit clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git\n然后将主题配置文件复制到 Hexo 根目录\ncp -f hexo-theme-butterfly/_config.yml ./_config.butterfly.yml\n\n升级方法：在主题目录下，运行 git pull\n\n应用主题修改 Hexo 根目录下的_config.yml ，把主题改为 butterfly\ntheme: butterfly\n\n如果你遇到了导航栏布局问题，请修改themes\\butterfly\\source\\css\\_layout\\head.styl加一个display: flex;\n&amp;.fixed  #nav    position: fixed    display: flex !important  // 这里，解决了导航栏和侧边栏垂直显示的问题  &amp; + .layout    &amp; &gt; .aside-content &gt; .sticky_layout      top: 70px      transition: top .5s    #card-toc      .toc-content        max-height: calc(100vh - 170px)\n","categories":["开发编程"],"tags":["博客"]},{"title":"搭建clash服务器","url":"/hexo/2025/07/26/createClashServer/","content":"\n这个文章是为了搭建一个clash服务器，用于代理网络流量，可是这样搭建的服务器只能用来代理http和https的流量，不够全局，比如不能打游戏啦，所以更推荐看这篇文章：这里\n\n需要的物品：\n外网的 vps（国外的服务器）,\n\nMicrosoft Azure 订阅\n腾讯云\n\n\n一个域名\n\n在这里获取一个域名\n\n\n一个SSL证书\n\n参考：这里\n\n\n\n具体步骤1. 进入vps，然后安装 1panel(bash -c &quot;$(curl -sSL https://resource.fit2cloud.com/1panel/package/v2/quick_start.sh)&quot;) # 在这个过程中会自动安装docker\n2. 将域名和IP绑定1. 登录cloudflare，将域名加入cloudflare的防御\n2. 进入https://dash.cloudflare.com/68e38eexxxxxxxxx/&lt;YOUR.DOMAIN.COM&gt;/dns\n3. 添加一条A记录，将域名指向vps的IP地址\n\n3. 安装证书参考：https://www.runoob.com/http/ssl-certbot.html生成的证书会在/etc/letsencrypt/live/&lt;YOUR.DOMAIN.COM/&gt;目录下，这个证书90天后就过期了，所以，需要定期更新证书手动更新:\ncertbot certonly --force-renewal --manual -d &#x27;&lt;YOUR.DOMAIN.COM/&gt;&#x27; \\--preferred-challenges dns \\--server https://acme-v02.api.letsencrypt.org/directory\n可以做一下证书的自动化更新。\n4. 运行代理服务器（关键）#!/bin/bash# 下面的四个参数需要改成你的DOMAIN=&quot;YOU.DOMAIN.NAME&quot;USER=&quot;username&quot;PASS=&quot;password&quot;PORT=443BIND_IP=0.0.0.0CERT_DIR=/etc/letsencryptCERT=$&#123;CERT_DIR&#125;/live/$&#123;DOMAIN&#125;/fullchain.pemKEY=$&#123;CERT_DIR&#125;/live/$&#123;DOMAIN&#125;/privkey.pemsudo docker run -d --name gost \\    -v $&#123;CERT_DIR&#125;:$&#123;CERT_DIR&#125;:ro \\    --net=host ginuerzh/gost \\    -L &quot;http2://$&#123;USER&#125;:$&#123;PASS&#125;@$&#123;BIND_IP&#125;:$&#123;PORT&#125;?cert=$&#123;CERT&#125;&amp;key=$&#123;KEY&#125;&amp;probe_resist=code:404&amp;knock=www.google.com&quot;\n\n关于 gost 的参数， 你可以参看其文档：Gost Wiki，上面我设置一个参数 probe_resist&#x3D;code:404 意思是，如果服务器被探测，或是用浏览器来访问，返回404错误，也可以返回一个网页（如：probe_resist&#x3D;file:&#x2F;path&#x2F;to&#x2F;file.txt 或其它网站 probe_resist&#x3D;web:example.com&#x2F;page.html）\n\n如无意外，你的服务就启起来了。 你可以使用如下命令在检查有没有启动成功：sudo docker ps 来查看 gost 是否在运行。netstat -nolp | grep 443 来查看 gost 是否在监听 443 端口。sudo docker logs gost 来查看 gost 的日志。你可以使用下面的命令验证你的 gost 服务是否正常。\ncurl -v &quot;https://www.google.com&quot; --proxy &quot;https://$&#123;DOMAIN&#125;&quot; --proxy-user &#x27;$&#123;USER&#125;:$&#123;PASS&#125;&#x27;\n5. 配置Clash下列为Clash配置文件示例\nmixed-port: 7890allow-lan: truebind-address: &#x27;*&#x27;mode: rulelog-level: infoexternal-controller: &#x27;127.0.0.1:9090&#x27;dns:    enable: false    ipv6: true    default-nameserver: [223.5.5.5, 119.29.29.29, 8.8.8.8]    enhanced-mode: fake-ip    fake-ip-range: 198.18.0.1/16    use-hosts: true    nameserver: [&#x27;https://doh.pub/dns-query&#x27;, &#x27;https://dns.alidns.com/dns-query&#x27;]    fallback: [&#x27;https://doh.dns.sb/dns-query&#x27;, &#x27;https://dns.cloudflare.com/dns-query&#x27;, &#x27;https://dns.twnic.tw/dns-query&#x27;, &#x27;tls://8.8.4.4:853&#x27;]    fallback-filter: &#123; geoip: true, ipcidr: [240.0.0.0/4, 0.0.0.0/32] &#125;proxies:    - &#123; name: &#x27;pansyliu-proxy&#x27;, type: http, server: &lt;YOUR.DOMAIN.COM/&gt;, port: 443, username: USER, password: PASS, tls: true ,http2: true&#125;","categories":["开发编程"],"tags":["网络代理"]},{"title":"Hello World","url":"/hexo/2025/10/11/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"qemu","url":"/hexo/2025/08/17/qemu/","content":"qemu 是一个开源的虚拟机软件，它可以在一个操作系统上运行另一个操作系统。\n安装user（网络功能）git clone https://gitlab.freedesktop.org/slirp/libslirp.gitcd libslirp/meson buildninja -C build installsudo ninja -C build install\n安装# 更新软件包索引sudo apt update# 克隆qemu仓库git clone https://github.com/qemu/qemu.git# 进入qemu目录cd qemusudo apt install meson -ysudo apt-get install libsdl2-2.0 -ysudo apt-get install libsdl2-dev -ysudo apt-get install libgtk-3-dev -y# 初始化子模块sudo apt install build-essential -y# 安装Python相关依赖（虚拟环境支持）sudo apt install python3-venv -y# 安装构建工具sudo apt install ninja-build -y# 安装pkg-config（依赖管理工具）和glib2.0开发库sudo apt install pkg-config libglib2.0-dev -y#kvm 支持sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils -y# 安装词法/语法分析工具sudo apt install flex bison -ysudo ./configure --enable-sdl --enable-gtk --enable-kvmcd buildmakesudo make install\n\n使用qemu-system-x86_64 -hda ubuntu.img -cdrom ubuntu.iso -boot d -m 4G\n"},{"title":"vmess协议代理搭建","url":"/hexo/2025/08/05/vmess/","content":"\n这种代理方式更方便，不需要域名，也不需要证书，只需要在客户端配置好vmess的地址和端口，就可以直接使用了，而且支持游戏加速，但是我没找到所谓的 rule 模式 所以是默认全局的这点非常不方便。\n\n搭建vmess服务器服务器端需要的物品：\n\n外网的 vps（国外的服务器）,\nMicrosoft Azure 订阅\n腾讯云\n\n\n一个健全的大脑\n一个有耐心的人\n\n运行安装脚本\nbash &lt;(curl -s -L https://raw.githubusercontent.com/xyz690/v2ray/master/install.sh)\n\n回车选择1安装然后协议选择2(tcp-http)，端口号默认即可，广告拦截别选，因为会减速可选安装 Shadowsocks （应该可以靠这个给clash使用，虽然我不会配置）复制一下链接\n客户端点击这里下载打开后直接ctrl+v导入该配置并启用然后打开设置，确认这两个参数：点击确定，接下来下载SSTAP(游戏加速器)，链接如下这里安装SSTAP下载后，运行SSTAP.exe程序,选择添加socks5：服务器IP填127.0.0.1，端口填10808，分组名称选default，country选择你的服务器地区，点击保存，返回进入主页面，模式下拉列表选择你的游戏，没有的话直接第一个全局内置规则即可，点击连接即启动游戏加速器，一般而言SG和HK的延迟在100ms左右，勉强是够用的，可以打打FPS。如果不用的话点击断开连接，否则可能会出现电脑浏览器连不上网络的情况\n","categories":["开发编程"],"tags":["网络代理"]},{"title":"在Vue中使用JSX","url":"/hexo/2025/08/01/vueUseJsx/","content":"\n最近在学习React，发现React的JSX语法非常强大，于是有一个想法：在Vue中使用JSX语法，发现确实支持，写下这篇文章记录一下。\n\nVue3 (Vite)\n安装插件\n\nnpm install @vitejs/plugin-vue-jsx\n\n配置 Vite修改 vite.config.js 或 vite.config.ts 文件：\n\nimport &#123; defineConfig &#125; from &#x27;vite&#x27;;import vue from &#x27;@vitejs/plugin-vue&#x27;;import vueJsx from &#x27;@vitejs/plugin-vue-jsx&#x27;;export default defineConfig(&#123;  plugins: [vue(), vueJsx()]&#125;);\n\n示例创建一个名为 MyApp.jsx 的文件，内容如下：\n\nimport &#123; defineComponent &#125; from &#x27;vue&#x27;export default defineComponent(&#123;    name: &quot;Myapp&quot;,    props: &#123;        msg: &#123; type: String &#125;    &#125;,    setup(props) &#123;        return () =&gt;(        &lt;div&gt;            &lt;h1&gt;hello &#123;props.msg&#125;&lt;/h1&gt;        &lt;/div&gt;        )    &#125;&#125;)\n\n为何这样写？不使用更简单的:\nexport default function Myapp(&#123;msg&#125;)&#123;   return (       &lt;div&gt;           &lt;h1&gt;hello &#123;msg&#125;&lt;/h1&gt;       &lt;/div&gt;   )&#125;\n这是因为：可以使用defineComponent来定义组件，这样可以使用vue的一些功能，比如props、setup,onMounted等。然后在 vue 文件中引入：\n\n&lt;template&gt;    &lt;div&gt;        &lt;h1&gt;home&lt;/h1&gt;        &lt;Myapp :msg=&quot;username&quot; /&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;&lt;/script&gt;&lt;script setup lang=&quot;tsx&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;import Myapp from &#x27;./MyApp.jsx&#x27;let username = ref(&quot;shaw&quot;)&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\nVue2 (Vue-CLI) Webpack安装依赖\npnpm install @vue/babel-preset-jsx @vue/babel-helper-vue-jsx-merge-props -D\n修改babel.config.js文件:\nmodule.exports = &#123;  presets: [    &#x27;@vue/cli-plugin-babel/preset&#x27;,    &#x27;@vue/babel-preset-jsx&#x27;  ]&#125;\n创建一个jsx文件：\n// 定义一个JSX组件const Hello = &#123;&#125;Hello.props = &#123;  name: &#123;    type: String,    default: &#x27;World&#x27;  &#125;&#125;// eslint-disable-next-line no-unused-varsHello.render = function(h) &#123;  return (    &lt;div className=&quot;hello&quot;&gt;      &lt;h1&gt;Hello, &#123;this.name&#125;!&lt;/h1&gt;      &lt;p&gt;This is a JSX component imported from a .jsx file&lt;/p&gt;    &lt;/div&gt;  )&#125;export default Hello\n修改App.vue\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;Hello name=&quot;Vue JSX&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Hello from &#x27;./components/Hello.jsx&#x27;export default &#123;  name: &#x27;App&#x27;,  components: &#123;    Hello  &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;","categories":["开发编程"],"tags":["vue","jsx"]},{"title":"创建Home Assistant服务","url":"/hexo/2025/08/23/%E5%88%9B%E5%BB%BAHome-Assistant%E6%9C%8D%E5%8A%A1/","content":"1.创建docker容器\nsudo docker run -d --name homeassistant --privileged --restart=unless-stopped -e TZ=Asia/Shanghai -v /data/homeassistant:/config --network=host homeassistant/home-assistantmkdir /data/homeassistantmkdir /data/homeassistant/wwwmkdir /data/homeassistant/custom_componentsmkdir /data/homeassistant/custom_components/hacscd /data/homeassistant/custom_components/hacswget https://github.com/hacs/integration/releases/download/2.0.5/hacs.zip # 下载hacs插件 可以自己下载最新版本unzip hacs.ziprm hacs.zip\n\n2.进入WebUI(http://IP:8123/developer-tools/yaml)重启Home Assistant服务\n3.进入 HACS ，下载Xiaomi Home 插件 并重启Home Assistant服务(http://IP:8123/developer-tools/yaml)\n4.进入 设置-&gt; 设备&amp;服务-&gt; 添加集成-&gt; 搜索Xiaomi Home 并添加\n"},{"title":"在termux编译opencv","url":"/hexo/2025/08/26/%E5%9C%A8termux%E7%BC%96%E8%AF%91opencv/","content":"pkg install build-essential cmake libjpeg-turbo libpng pythongit clone https://github.com/opencv/opencv# 进入管理员环境termux-chrootcd opencvmkdir buildcd buildLDFLAGS=&quot; -llog -lpython3&quot; cmake -DCMAKE_BUILD_TYPE=RELEASE -DCMAKE_INSTALL_PREFIX=$PREFIX -DBUILD_opencv_python3=on -DBUILD_opencv_python2=off -DOPENCV_EXTRA_MODULES=../modules -DPYTHON3_LIBRARIES=$PREFIX/lib/libpython3.so -DWITH_QT=OFF -DWITH_GTK=OFF -DBUILD_JAVA=OFF -DBUILD_ANDROID_EXAMPLES=OFF ..makemake install"},{"title":"注入任意代码到运行中的 Electron 应用","url":"/hexo/2025/10/11/%E6%B3%A8%E5%85%A5%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%B0%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84-Electron-%E5%BA%94%E7%94%A8/","content":"本文转自 https://cn-sec.com/archives/1899908.html\n\n第一次发布手滑，发现马赛克没打干净，只能重发了\nElectron 这玩意儿是开发起来爽，用起来想吐。不知不觉电脑上装了一个又一个臃肿不堪的 Chromium 副本，不知给全球变暖贡献了多少碳排放量。怪不得这几年天气越来越变态。\n新的 “NT 架构” QQ 也加入了 Electron 大军。\n记得几年前还能见到 QQProtect 的驱动。最近主力机不用 Windows，不清楚了。换 Electron 确实可以一套代码跨平台，但这样一来别说进程保护，这破框架还自带了运行时代码注入的接口。\n大概是 PC 端逐渐式微，现在没什么人做什么尾巴、盗号之类的事情，所以没必要再折腾保护了？\n本来想在 Windows 下面演示。我的 Windows 开了 OneDrive 同步，直接触发了一个 bug。\n\n还是继续 Mac。\nElectron 即使是打包到生产环境，仍然带了调试器后门。\n带上参数 –remote-debugging-port，然后用 Chrome 的 chrome:&#x2F;&#x2F;inspect 页面，或者直接用 websocket 和调试协议通信，就能在 electron 上下文执行任意 js。以前还出过利用 DNS rebinding 实现完全远程代码执行的例子。\n开发者可以在业务初始化的代码里直接检测这个 flag，拒绝执行。同时也不能处理 app 进程已经在运行的情况。\n不过 Node.js 很贴心地给了另一个动态启用调试的方式，命令行发送 SIGUSR1 信号：\nkill -SIGUSR1 [pid]\nWindows 没有对应的机制，需要在 nodejs 里用\nprocess._debugProcess(pid)\n源码在这里，可以看到 Windows 下还是用的 CreateRemoteThread。\nhttps://github.com/nodejs/node/blob/9dd574c9e232/src/node_process_methods.cc#L348\n应该不会被终端安全软件放过吧……\n开启了调试之后就可以在 Chrome 的里看到远程调试目标了：然后就可以整活了\nrequire(&#x27;electron&#x27;).webContents.getAllWebContents()  .forEach(c =&gt; c.loadURL(&#x27;javascript:alert(location)&#x27;))\n想注入二进制模块？写一个 dll，process.dlopen 一下。\n这是框架的特性，不是安全边界。毕竟都能运行任意本地代码了，能干的事情太多了。但如果你很介意进程被人乱插代码，可能在用 Electron 之前要好好考虑一番。\n原文始发于微信公众号（非尝咸鱼贩）：注入任意代码到运行中的 Electron 应用\n"},{"title":"网页防止休眠","url":"/hexo/2025/09/29/%E7%BD%91%E9%A1%B5%E9%98%B2%E6%AD%A2%E4%BC%91%E7%9C%A0/","content":"今天才知道，Web网页也能阻止息屏了这篇文章发布于 2024年03月17日，星期日，23:35，归类于 JS API。 阅读 22103 次, 今日 13 次 8 条评论\nby zhangxinxu from https://www.zhangxinxu.com/wordpress/?p=11135 鑫空间-鑫生活本文欢迎分享与聚合，全文转载就不必了，尊重版权，圈子就这么大，若急用可以联系授权。\nwake up\n一、阻止屏幕黑屏休眠之前做PPT录制的时候，一个电脑显示台词，一个电脑录制，然后显示台词的那个电脑没几分钟就黑屏，烦不胜烦，没办法，就打开一个视频，窗口小小的，也就是画中画模式，\n今天才发现，原来不久前，Chrome和Safari浏览器都支持了名为Screen Wake Lock的API，可以设置Web网页打开的状态下，显示器屏幕不会自动休眠。\n根据我查找的资料显示，美国知名烹饪网站 Betty Crocker 实现 Screen Wake Lock API 后， 发现其用户的购买意愿指标增加了 300%。如需了解详情，请参阅 ?? Betty Crocker 案例研究。\n这还真是意外，居然还可以增加产品的直接收益。\n不过应该只对特定网站有用，像是做饭的网站，用户做菜的时候，肯定是希望网页一直亮着的，因为要时不时看，所以，收益才这么明显。\n如果是传统的社交网站应该作用就一般了，不知道小说阅读类网站的收益如何……\n这个之后再议，当下我就有一个需求场景，某项目介绍页面，进入演讲模式的时候，一定是不能息屏的。\n就可以使用这里的Screen Wake Lock API了。\n二、屏幕唤起锁定API的语法与使用这种语法简单的API的最快捷的学习方式就是案例。\n您可以狠狠地点击这里：显示器屏幕唤起锁定JS实现demo\n只要勾选如下图所示的复选框，那么，无论等待多久，屏幕都会一直保持亮蹭蹭的状态。\n屏幕唤起锁定交互示意\n语法与使用要想屏幕保持唤起状态，很简单，一行代码的事情：\nnavigator.wakeLock.request(‘screen’);结束了，就这么简单。\n结束了\n由于保持屏幕唤醒是一个占用资源开销的操作，所以，浏览器有个行为，那就是如果当前页面最小化，或者非当前显示标签页，屏幕的Wake锁定行为会被释放，用户再切换过来的时候，就没有锁定了，因此，还需要其他代码的处理。\ndocument.addEventListener(‘visibilitychange’, () &#x3D;&gt; {  if (document.visibilityState &#x3D;&#x3D;&#x3D; ‘visible’) {    navigator.wakeLock.request(“screen”)  }});还没完，如果仅仅只是wakeLock，在实操过程中，很容易重复执行唤醒锁定，因此，还需要知道什么时候释放了屏幕唤醒操作，以及如何主动释放禁止熄屏的功能。\n这就要说一说 WakeLockSentinel 对象了，该对象是navigator.wakeLock.request(‘screen’)这个Promise执行后的返回值。\n我们可以使用then()获取，例如：\nlet wakeLock &#x3D; null;navigator.wakeLock.request(‘screen’).then(result &#x3D;&gt; {    wakeLock &#x3D; result;})也可以使用async&#x2F;await语法，例如：\nlet wakeLock &#x3D; null;async () &#x3D;&gt; {    wakeLock &#x3D; await navigator.wakeLock.request(‘screen’);}主动释放\n想要释放熄屏锁定，则可以借助上面的wakeLock对象，代码示意：\nwakeLock.release().then(() &#x3D;&gt; {  wakeLock &#x3D; null;});以及，我们可以知道什么时候唤醒锁定是什么时候释放的，使用release事件：\nwakeLock.addEventListener(‘release’, () &#x3D;&gt; {    console.log(‘唤醒锁定已释放’);});相关代码在demo演示页面均有体现。\n三、劲酒虽好，可别贪杯屏幕唤起锁定不是没有代价的，如果屏幕一直保持明亮，会阻止屏幕保护程序的启动，会影响显示器的寿命。\n对于移动设备，屏幕往往是最耗电的，因此，阻止熄屏会带来更高的电量开销，因此，非必要场景是不推荐启用熄屏锁定的。\n要求\n此API要想生效，需要是https协议，或者是localhost本地环境。\n兼容性\n目前Chrome和Safari浏览器均已经支持wake-lock特性，Firefox已经开启实验支持，按照历史经验，没多久就会正式支持了，此API全面使用指日可待。\nscreen wake lock 兼容性\n碎碎念时间\n春节前新书写完，于是决定给自己放三个月的假，每天早睡，每周钓两场鱼，自然而然，文章更新频率就下来了。\n一转眼，也是快40的人了，时间真的是块，今天还看了自己10年前的照片，仿佛就在昨天。\n心态也变了很多，更平和，更稳定了，但也造成创造力下降了，以往的那些奇思妙想现在很难再迸发出来了，所以，究竟是变得更好还是有所退步，一时也说不清楚。\n一直想什么时候弄个鱼塘玩玩，可惜当下没有那么多时间和精力，难道要等退休，或者兼职搞鱼塘，不行不行，没那么多时间。\n哎呀，想远了，先换个可以随便养鱼的大房子再说吧。\n????\n"}]